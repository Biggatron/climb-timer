<!DOCTYPE html>
<html lang="en">

<head>
  <%- include('../partials/head'); %>
  <link rel="stylesheet" href="/css/timer.css" type="text/css">
</head>

<body class="body-container">

  <header>
    <%- include('../partials/header', {navItem: 'timer' }); %>
  </header>

  <main>
    <div class="content-container">
      <div class="center-col-container">
        <h1 class="center-self" id="timerRound">Round 1</h1>
        <div class="timers-container">
          <div class="timer-text-container" id="timer-container">
            <div class="timer-text" id="timerMin"></div>
            <div class="timer-text">:</div>
            <div class="timer-text" id="timerSec"></div>
          </div>
          <div class="space-between-row timer-controls-container">
            <button title="Sound On/off" id="toggleSoundButton" class="btn btn-icon timer-button-unmute" onClick="toggleSound()"></button>
            <% if (!user) { %>
            <% } else if (user.id===timer.user_id) { %>
              <div class="center-row-container">
                <button title="Sync connected timers" id="syncTimersButton" class="btn btn-icon timer-button-sync" onClick="syncToConnectedTimers()"></button>
                <button title="Play/Pause" id="toggleTimerButton" class="btn btn-icon timer-button-play" onClick="toggleTimer()"></button>
                <button title="Initialize timer" id="resetTimerButton" class="btn btn-icon timer-button-reset" onClick="resetTimer()"></button>
              </div>
            <% } %>
            <button title="Toggle Fullscreen" id="toggleTimerFullscreen" class="btn btn-icon timer-button-fullscreen" onClick="toggleFullscreen()"></button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <%- include('../partials/footer'); %>
  </footer>
  <script src="/scripts/socket.io.js"></script>
  <script src="/scripts/noSleep.js"></script>
  <audio preload="auto" id="shortBeep" src="/media/shortBeep.wav"></audio>
  <audio preload="auto" id="longBeep" src="/media/longBeep.wav"></audio>
  <script>
  </script>
</body>
</html>

<script>
  let timer, user;
  // if ( <% - user !== undefined %> ) {
    user = '<%- JSON.stringify(user) %>';
  if (user) {
    user = JSON.parse(user);
  }

  //if ( <% - timer !== undefined %> ) {
    timer = `<%- JSON.stringify(timer) %>`;
    timer = JSON.parse(timer);
  //}

  let socket = io({
    query: {
      timerCode: timer.timer_code,
      userId : user.id,
      timerUserId : timer.user_id
    }
  });

  let noSleep = new NoSleep();
  let isNoSleepActive = false;

  var soundOn = false;
  var shortBeep = document.getElementById("shortBeep");
  var longBeep = document.getElementById("longBeep");
  var timerContainerEl = document.getElementById("timer-container");
  timerContainerEl.addEventListener("fullscreenchange", fullscreenChanged);
  timerContainerEl.addEventListener("fullscreenchange", enableNoSleep);

  var roundTime = timer.timer_duration * 1000 + timer.timer_buffer * 1000;
  var timerInterval;
  var intervalDelay;
  var startTimeStamp;
  var pauseTimeStamp;

  let timerMinEl = document.getElementById('timerMin');
  let timerSecEl = document.getElementById('timerSec');
  let bufferMinEl = document.getElementById('bufferMin');
  let bufferSecEl = document.getElementById('bufferSec');
  let timerRoundEl = document.getElementById('timerRound');

  let toggleTimerButton = document.getElementById('toggleTimerButton');
  let toggleSoundButton = document.getElementById('toggleSoundButton');

  initializeTimer();
  updateTimerEl();
  if (!timer.is_paused) { 
    startTimer();
  };

  function playSound() {
    // If sound is off then leave function
    if (!soundOn) {
      return;
    }

    if (timer.bufferActive) {
      if (timer.bufferMin === 0 && timer.bufferSec === 0 ) {
        longBeep.play(); // timer starts at initial-1 so sound is played when buffer reaches zero
      }
      return;
    } else if (timer.timerMin === timer.timerMinOrig && timer.timerSec === timer.timerSecOrig) {
      longBeep.play(); // When initial and start timer is pressed
    } else if (timer.timerMin === 1 && timer.timerSec === 0) {
      shortBeep.play();
    } else if (timer.timerMin !== 0) {
      return;
    } else if (timer.timerSec === 0) {
      longBeep.play();
    } else if (timer.timerSec < 5 ) {
      shortBeep.play();
    }
  };

  socket.on("startTimer", (socketTimer) => {
    timer = socketTimer;
    console.log('start timer með socket')
    startTimer(150);
  });

  socket.on("pauseTimer", (socketTimer) => {
    timer = socketTimer;
    console.log("Pause timer með socket")
    pauseTimer();
  });

  socket.on("syncTimer", (socketTimer) => {
    console.log('Timer synced from master')
    timer = socketTimer;
    updateTimerEl();
    if (timer.is_paused) {
      pauseTimer();
    } else {
      clearInterval(timerInterval);
      timerInterval = null;
      startTimer(150);
    }
  });

socket.on("syncRequest", (socketTimer) => {
  // Only master timer will answer sync request
  if ( user.id !== timer.user_id ) { return };
  console.log('SyncRequest answered');
  syncToConnectedTimers();
});

function syncToConnectedTimers() {
    if (timer.is_paused) {
      socket.emit('syncTimer', timer);
    } else {
      let tempTimer = structuredClone(timer);
      let currTimeStamp = new Date();
      let timeDiff = currTimeStamp - startTimeStamp;
      tempTimer.time_elapsed = timer.time_elapsed + timeDiff;
      socket.emit('syncTimer', tempTimer);
    }
}

  socket.on("resetTimer", (socketTimer) => {
    timer = socketTimer;
    console.log("Reset timer með socket")
    timer.time_elapsed = 0;
    pauseTimer();
    initializeTimer();
    updateTimerEl();
  });

function initializeTimer() {
  timer.timerMinOrig = Math.floor(timer.timer_duration / 60);
  timer.timerSecOrig = timer.timer_duration % 60;
  timer.bufferMinOrig = Math.floor(timer.timer_buffer / 60);
  timer.bufferSecOrig = timer.timer_buffer % 60;
  timer.round = 1;

  if (timer.time_elapsed) {
    let timerRemaining, bufferRemaining;
    let timerElapsedMod = timer.time_elapsed % roundTime;

    // Get the round number from elapsed time
    if (timer.time_elapsed > roundTime) {
      timer.round += Math.floor(timer.time_elapsed / roundTime);
    }
    // Set timer and buffer from elapsed time
    if ( timerElapsedMod < timer.timer_duration * 1000) {
      timerRemaining = timer.timer_duration * 1000 - timerElapsedMod;
      bufferRemaining = timer.timer_buffer * 1000;
      timer.bufferActive = false;
    } else if ( timerElapsedMod < roundTime ) {
      timerRemaining = 0;
      bufferRemaining = timer.timer_buffer * 1000 - (timerElapsedMod - timer.timer_duration * 1000);
      timer.bufferActive = true;
    };

    timerRemaining = Math.floor( timerRemaining / 1000);
    bufferRemaining = Math.floor( bufferRemaining / 1000);
    timerRemaining
    timer.timerMin = Math.floor(timerRemaining / 60);
    timer.timerSec = timerRemaining % 60;
    timer.bufferMin = Math.floor(bufferRemaining / 60);
    timer.bufferSec = bufferRemaining % 60;
  } else {
    timer.timerMin = timer.timerMinOrig;
    timer.timerSec = timer.timerSecOrig;
    timer.bufferMin = timer.bufferMinOrig;
    timer.bufferSec = timer.bufferSecOrig;
    timer.bufferActive = false;
  }
}

  function updateTimerEl() {
    if (timer.timerMin < 10) {
      if (timer.bufferActive) {
        timerMinEl.innerText = zeroPad(timer.bufferMin.toString());
        timerSecEl.innerText = zeroPad(timer.bufferSec.toString());
        timerContainerEl.style.backgroundColor = "#fffb80";
      } else {
        timerMinEl.innerText = zeroPad(timer.timerMin.toString());
        timerSecEl.innerText = zeroPad(timer.timerSec.toString());
      }
      //bufferMinEl.innerText = zeroPad(timer.bufferMin.toString());
      //bufferSecEl.innerText = zeroPad(timer.bufferSec.toString());
      timerRoundEl.innerText = "Round " + timer.round;
    }
    updateTimerBackgroundColor();
  }

  function updateTimerBackgroundColor() {
    if (timer.bufferActive) {
        timerContainerEl.style.backgroundColor = "#FFFB80";
    } else {
      if (timer.rotating_background_color) {
        if ( timer.round % 2 === 0 ) {
          timerContainerEl.style.backgroundColor = "#93B5FF";
        } else {
          timerContainerEl.style.backgroundColor = "#93FF9F";
        }
      } else {
        timerContainerEl.style.backgroundColor = "#93FF9F";
      }
    }
  }

  function zeroPad(num) {
    if (num.length === 1) {
      return "0" + num;
    } else {
      return num;
    }
  }

  function toggleTimer() {
    // timerInterval indicates whether timer is active or not
    if (timerInterval) {
      pauseTimerClick();
    } else {
      startTimerClick();
    }
  }

  function startTimerClick() {
    socket.emit('startTimer', timer);
    playSound();
    startTimer();
  }

  function pauseTimerClick() {
    // set time elapsed to provide database. 
    pauseTimeStamp = new Date();
    let timeDiff = pauseTimeStamp - startTimeStamp;
    timer.time_elapsed = timer.time_elapsed + timeDiff;
    timer.lookup = 'lookup';
    socket.emit('pauseTimer', timer);
    pauseTimer();
  }

  function startTimer(delay = 0) {
    // If interval exists then the timer is already running. 
    if (timerInterval) return;
    
    console.log('Starting timer with ' + delay + ' ms delay');
    
    // Save timestamp to calculate elapsed time on next pause. 
    startTimeStamp = new Date();
    // Set timer as started
    timer.is_paused = false;
    // To make up for server client delay
    timer.time_elapsed += delay; 

    // If time has passed then we need to start the interval at the next whole second.
    // For example if time elapsed is 15200ms then we'll wait for 800ms to start the 
    // interval that will then update the timer every whole second. 
    if (timer.time_elapsed) {
      intervalDelay = 1000 - ( timer.time_elapsed % 1000 ); 

      // If provided network delay is larger than the intervalDelay then that means
      // that the delay pushed the timer passed the current second.
      if (delay > intervalDelay) {
        console.log('Timer should be a second behind master, but it isnt?')
      } 

      setTimeout( () => {
        // If timer was synced while timeout was active then this should be aborted
        if (timerInterval) return;
        timerStep();
        timerInterval = setInterval(timerStep, 1000);
      }, intervalDelay); 
    // Else timer is being started for the first time and then 04:00 needs to immediately
    // change to 03:59 and start counting from there. 
    } else {
      timerStep();
      timerInterval = setInterval(timerStep, 1000);
    }

    // Uppfæra play/pause takka
    if (user.id === timer.user_id) {
      toggleTimerButton.classList.add('timer-button-pause');
      toggleTimerButton.classList.remove('timer-button-play');
    }
  }

  function timerStep() {
    if (timer.timerSec > 0) {
      timer.timerSec--;
      timer.bufferActive = false;
    } else if (timer.timerMin > 0) {
      timer.timerMin--;
      timer.timerSec = 59;
      timer.bufferActive = false;
    } else if (timer.bufferSec > 0) {
      timer.bufferSec--;
      timer.bufferActive = true;
    } else if (timer.bufferMin > 0) {
      timer.bufferMin--;
      timer.bufferSec = 59;
      timer.bufferActive = true;
    } else {
      timer.round++;
      timer.timerMin = timer.timerMinOrig;
      timer.timerSec = timer.timerSecOrig;
      timer.bufferMin = timer.bufferMinOrig;
      timer.bufferSec = timer.bufferSecOrig;
      timer.bufferActive = false;
      // A timer thats 04:00 should start at 03:59 so we have to initilize the round with one sec elapsed
      timerStep();
    }
    updateTimerEl();
    playSound();
  }

  function pauseTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
    timer.is_paused = true;

    // Uppfæra play/pause takka
    if (user.id === timer.user_id) {
      toggleTimerButton.classList.add('timer-button-play');
      toggleTimerButton.classList.remove('timer-button-pause');
    }
  };

  function toggleFullscreen() {
    let timerTextEls = timerContainerEl.children;
    for (let i = 0; i < timerTextEls.length; i++) {
      timerTextEls[i].classList.add("timer-text-fullscreen");
    }
    timerContainerEl.requestFullscreen();
  }

  function fullscreenChanged(event) {
    if (!document.fullscreenElement) {
      let timerTextEls = timerContainerEl.children;
      for (let i = 0; i < timerTextEls.length; i++) {
        timerTextEls[i].classList.remove("timer-text-fullscreen");
      }
      disableNoSleep();
    } else {
      enableNoSleep();
    }
  }

  function enableNoSleep() {
    if (isMobileOrTablet() && !isNoSleepActive) {
      noSleep.enable();
      console.log('NoSleep activated')
    }
  }

  function disableNoSleep() {
    if (isNoSleepActive) {
      noSleep.disable();
      isNoSleepActive = false;
      console.log('NoSleep deactivated')
    }
  }
  
  function isMobileOrTablet() {
    let check = false;
    (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
    return check;
  };

  function toggleSound() {
    if (soundOn) {
      soundOn = false;
      toggleSoundButton.classList.add('timer-button-unmute');
      toggleSoundButton.classList.remove('timer-button-mute');
    } else {
      soundOn = true;
      toggleSoundButton.classList.add('timer-button-mute');
      toggleSoundButton.classList.remove('timer-button-unmute');
    }
  }

  function resetTimer() {
    timer.time_elapsed = 0;
    initializeTimer();
    updateTimerEl();
    socket.emit('resetTimer', timer);
    pauseTimer();
  }
  
  document.addEventListener("keydown", (event) => {
    // 32 = space, 80 = p, f = 70, m = 77
    if (event.keyCode === 32 || event.keyCode === 80) {
      toggleTimer();
      return;
    } else if (event.keyCode === 70) {
      toggleFullscreen();

    } else if (event.keyCode === 77) {
      toggleSound();
    }
  })

</script>